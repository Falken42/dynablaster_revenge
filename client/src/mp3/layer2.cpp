#include "mpegstream.h"
#include "decode.h"
#include <math.h>

#define REAL_SCALE_LAYER12(x)				(x)
#define REAL_MUL_SCALE_LAYER12(x, y)		((x) * (y))

static int grp_3tab[32 * 3] = { 0, };   // used: 27 
static int grp_5tab[128 * 3] = { 0, };  // used: 125 
static int grp_9tab[1024 * 3] = { 0, }; // used: 729 

static const struct al_table alloc_0[] = {
   {4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
   {11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
   {4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
   {11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
   {4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
   {11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767} };

static const struct al_table alloc_1[] = {
   {4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
   {11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
   {4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
   {11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
   {4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
   {11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
   {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767},
   {2,0},{5,3},{7,5},{16,-32767} };

static const struct al_table alloc_2[] = {
   {4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
   {10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
   {4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
   {10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63} };

static const struct al_table alloc_3[] = {
   {4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
   {10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
   {4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
   {10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63} };

static const struct al_table alloc_4[] = {
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
      {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
      {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
      {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
   {4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
      {9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
   {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9},
    {2,0},{5,3},{7,5},{10,9}  };


static const double mulmul[27] =
{
	0.0 , -2.0/3.0 , 2.0/3.0 ,
	2.0/7.0 , 2.0/15.0 , 2.0/31.0, 2.0/63.0 , 2.0/127.0 , 2.0/255.0 ,
	2.0/511.0 , 2.0/1023.0 , 2.0/2047.0 , 2.0/4095.0 , 2.0/8191.0 ,
	2.0/16383.0 , 2.0/32767.0 , 2.0/65535.0 ,
	-4.0/5.0 , -2.0/5.0 , 2.0/5.0, 4.0/5.0 ,
	-8.0/9.0 , -4.0/9.0 , -2.0/9.0 , 2.0/9.0 , 4.0/9.0 , 8.0/9.0
};

void Layer2::init()
{
	const int base[3][9] =
	{
		{ 1 , 0, 2 , } ,
		{ 17, 18, 0 , 19, 20 , } ,
		{ 21, 1, 22, 23, 0, 24, 25, 2, 26 }
	};
	int i,j,k,l,len;
	const int tablen[3] = { 3 , 5 , 9 };
	int *itable;
	int *tables[3] = { grp_3tab , grp_5tab , grp_9tab };

	for(i=0;i<3;i++)
	{
		itable = tables[i];
		len = tablen[i];
		for(j=0;j<len;j++)
		for(k=0;k<len;k++)
		for(l=0;l<len;l++)
		{
			*itable++ = base[i][l];
			*itable++ = base[i][k];
			*itable++ = base[i][j];
		}
	}
}

void init_layer12_stuff(MpegStream *fr)
{
	int k;
	float *table;
	for(k=0;k<27;k++)
	{
      table = init_layer12_table(fr->muls[k], k);
		*table++ = 0.0;
	}
}

float* init_layer12_table(float *table, int m)
{
	int i,j;
	for(j=3,i=0;i<63;i++,j--)
	   *table++ = (float) (mulmul[m] * pow(2.0,(double) j / 3.0));

	return table;
}

static void II_step_one(unsigned int *bit_alloc,int *scale,MpegStream *fr)
{
	int stereo = fr->mChannels-1;
   int sblimit = fr->layer2.II_sblimit;
	int jsbound = fr->mJointStereo;
   int sblimit2 = fr->layer2.II_sblimit<<stereo;
	const struct al_table *alloc1 = fr->alloc;
	int i;
	unsigned int scfsi_buf[64];
	unsigned int *scfsi,*bita;
	int sc,step;

	bita = bit_alloc;
	if(stereo)
	{
		for(i=jsbound;i;i--,alloc1+=(1<<step))
		{
			step=alloc1->bits;
			*bita++ = (char) fr->getbits(step);
			*bita++ = (char) fr->getbits(step);
		}
		for(i=sblimit-jsbound;i;i--,alloc1+=(1<<step))
		{
			step=alloc1->bits;
			bita[0] = (char) fr->getbits(step);
			bita[1] = bita[0];
			bita+=2;
		}
		bita = bit_alloc;
		scfsi=scfsi_buf;

		for(i=sblimit2;i;i--)
		if(*bita++) *scfsi++ = (char) fr->getbits_fast(2);
	}
	else // mono 
	{
		for(i=sblimit;i;i--,alloc1+=(1<<step))
		{
			step=alloc1->bits;
			*bita++ = (char) fr->getbits(step);
		}
		bita = bit_alloc;
		scfsi=scfsi_buf;
		for(i=sblimit;i;i--)
		if(*bita++) *scfsi++ = (char) fr->getbits_fast(2);
	}

	bita = bit_alloc;
	scfsi=scfsi_buf;
	for(i=sblimit2;i;i--)
	if(*bita++)
	switch(*scfsi++)
	{
		case 0: 
			*scale++ = fr->getbits_fast(6);
			*scale++ = fr->getbits_fast(6);
			*scale++ = fr->getbits_fast(6);
		break;
		case 1 : 
			*scale++ = sc = fr->getbits_fast(6);
			*scale++ = sc;
			*scale++ = fr->getbits_fast(6);
		break;
		case 2: 
			*scale++ = sc = fr->getbits_fast(6);
			*scale++ = sc;
			*scale++ = sc;
		break;
		default:              // case 3 
			*scale++ = fr->getbits_fast(6);
			*scale++ = sc = fr->getbits_fast(6);
			*scale++ = sc;
		break;
	}
}


static void II_step_two(unsigned int *bit_alloc,float fraction[2][4][SBLIMIT],int *scale,MpegStream *fr,int x1)
{
	int i,j,k,ba;
	int stereo = fr->mChannels;
   int sblimit = fr->layer2.II_sblimit;
	int jsbound = fr->mJointStereo;
	const struct al_table *alloc2,*alloc1 = fr->alloc;
	unsigned int *bita=bit_alloc;
	int d1,step;

	for(i=0;i<jsbound;i++,alloc1+=(1<<step))
	{
		step = alloc1->bits;
		for(j=0;j<stereo;j++)
		{
			if( (ba=*bita++) ) 
			{
				k=(alloc2 = alloc1+ba)->bits;
				if( (d1=alloc2->d) < 0) 
				{
					float cm=fr->muls[k][scale[x1]];
					fraction[j][0][i] = (float)((int)fr->getbits(k) + d1) * cm;
					fraction[j][1][i] = (float)((int)fr->getbits(k) + d1) * cm;
					fraction[j][2][i] = (float)((int)fr->getbits(k) + d1) * cm;
				}        
				else 
				{
					const int *table[] = { 0,0,0,grp_3tab,0,grp_5tab,0,0,0,grp_9tab };
					unsigned int idx,*tab,m=scale[x1];
					idx = (unsigned int) fr->getbits(k);
					tab = (unsigned int *) (table[d1] + idx + idx + idx);
					fraction[j][0][i] = REAL_SCALE_LAYER12(fr->muls[*tab++][m]);
					fraction[j][1][i] = REAL_SCALE_LAYER12(fr->muls[*tab++][m]);
					fraction[j][2][i] = REAL_SCALE_LAYER12(fr->muls[*tab][m]);  
				}
				scale+=3;
			}
			else
			fraction[j][0][i] = fraction[j][1][i] = fraction[j][2][i] = (float)(0.0);
		}
	}

	for(i=jsbound;i<sblimit;i++,alloc1+=(1<<step))
	{
		step = alloc1->bits;
		bita++;	// channel 1 and channel 2 bitalloc are the same
		if( (ba=*bita++) )
		{
			k=(alloc2 = alloc1+ba)->bits;
			if( (d1=alloc2->d) < 0)
			{
				float cm;
				cm=fr->muls[k][scale[x1+3]];
				fraction[0][0][i] = (float)((int)fr->getbits(k) + d1);
				fraction[0][1][i] = (float)((int)fr->getbits(k) + d1);
				fraction[0][2][i] = (float)((int)fr->getbits(k) + d1);
				fraction[1][0][i] = REAL_MUL_SCALE_LAYER12(fraction[0][0][i], cm);
				fraction[1][1][i] = REAL_MUL_SCALE_LAYER12(fraction[0][1][i], cm);
				fraction[1][2][i] = REAL_MUL_SCALE_LAYER12(fraction[0][2][i], cm);
				cm=fr->muls[k][scale[x1]];
				fraction[0][0][i] = REAL_MUL_SCALE_LAYER12(fraction[0][0][i], cm);
				fraction[0][1][i] = REAL_MUL_SCALE_LAYER12(fraction[0][1][i], cm);
				fraction[0][2][i] = REAL_MUL_SCALE_LAYER12(fraction[0][2][i], cm);
			}
			else
			{
				const int *table[] = { 0,0,0,grp_3tab,0,grp_5tab,0,0,0,grp_9tab };
				unsigned int idx,*tab,m1,m2;
				m1 = scale[x1]; m2 = scale[x1+3];
				idx = (unsigned int) fr->getbits(k);
				tab = (unsigned int *) (table[d1] + idx + idx + idx);
				fraction[0][0][i] = REAL_SCALE_LAYER12(fr->muls[*tab][m1]); fraction[1][0][i] = REAL_SCALE_LAYER12(fr->muls[*tab++][m2]);
				fraction[0][1][i] = REAL_SCALE_LAYER12(fr->muls[*tab][m1]); fraction[1][1][i] = REAL_SCALE_LAYER12(fr->muls[*tab++][m2]);
				fraction[0][2][i] = REAL_SCALE_LAYER12(fr->muls[*tab][m1]); fraction[1][2][i] = REAL_SCALE_LAYER12(fr->muls[*tab][m2]);
			}
			scale+=6;
		}
		else
		{
			fraction[0][0][i] = fraction[0][1][i] = fraction[0][2][i] =
			fraction[1][0][i] = fraction[1][1][i] = fraction[1][2][i] = (float)(0.0);
		}
/*
	Historic comment...
	should we use individual scalefac for channel 2 or
	is the current way the right one , where we just copy channel 1 to
	channel 2 ?? 
	The current 'strange' thing is, that we throw away the scalefac
	values for the second channel ...!!
	-> changed .. now we use the scalefac values of channel one !! 
*/
	}

   if(sblimit > SBLIMIT)
      sblimit = SBLIMIT;

	for(i=sblimit;i<SBLIMIT;i++)
      for (j=0;j<stereo;j++)
         fraction[j][0][i] = fraction[j][1][i] = fraction[j][2][i] = 0.0f;
}


static void II_select_table(MpegStream *fr)
{
	const int translate[3][2][16] =
	{
		{
			{ 0,2,2,2,2,2,2,0,0,0,1,1,1,1,1,0 },
			{ 0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,0 }
		},
		{
			{ 0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0 },
			{ 0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0 }
		},
		{
			{ 0,3,3,3,3,3,3,0,0,0,1,1,1,1,1,0 },
			{ 0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,0 }
		}
	};

	int table,sblim;
	const struct al_table *tables[5] = { alloc_0, alloc_1, alloc_2, alloc_3 , alloc_4 };
	const int sblims[5] = { 27 , 30 , 8, 12 , 30 };

   if(fr->mSampleRate >= 3)
	table = 4;
	else
   table = translate[fr->mSampleRate][2-fr->mChannels][fr->mBitrateIndex];

	sblim = sblims[table];
	fr->alloc      = tables[table];
   fr->layer2.II_sblimit = sblim;
}


int Layer2::process(MpegStream *fr)
{
	int clip=0;
	int i,j;
	// pick_table clears unused subbands 
	float (*fraction)[4][SBLIMIT] = fr->layer2.fraction;
	unsigned int bit_alloc[64];
	int scale[192];

	II_select_table(fr);
   fr->mJointStereo = (fr->mMode == MPG_MD_JOINT_STEREO) ? (fr->mModeExt<<2)+4 : fr->layer2.II_sblimit;

   if(fr->mJointStereo > fr->layer2.II_sblimit)
	{
		fprintf(stderr, "Truncating stereo boundary to sideband limit.\n");
      fr->mJointStereo=fr->layer2.II_sblimit;
	}

	II_step_one(bit_alloc, scale, fr);

	for(i=0;i<SCALE_BLOCK;i++)
	{
		II_step_two(bit_alloc,fraction,scale,fr,i>>2);
		for(j=0;j<3;j++) 
		{
			if(fr->mChannels == 1)
			   clip += synth_1to1_mono(fraction[0][j], fr);
			else
			   clip += synth_stereo_wrap(fraction[0][j], fraction[1][j], fr);
		}
	}

	return clip;
}
